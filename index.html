<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Particles Camera v4 â€“ Neon Flow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        :root { --primary: #00f3ff; --glass: rgba(255, 255, 255, 0.1); }
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        
        /* UI LAYOUT */
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* START BUTTON */
        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 18px 40px; font-size: 18px; font-weight: bold; letter-spacing: 2px;
            color: #fff; background: transparent; border: 1px solid var(--primary);
            box-shadow: 0 0 15px var(--primary); text-transform: uppercase; cursor: pointer;
            pointer-events: auto; transition: 0.3s; border-radius: 4px;
        }
        #start-btn:hover { background: var(--primary); color: #000; box-shadow: 0 0 30px var(--primary); }

        /* HUD ELEMENTS */
        .hud-panel {
            position: absolute; background: var(--glass); backdrop-filter: blur(10px);
            padding: 10px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);
            color: #eee; font-size: 14px; transition: opacity 0.5s;
        }
        #instructions { top: 20px; left: 20px; max-width: 250px; line-height: 1.5; }
        #status { top: 20px; right: 20px; font-weight: bold; color: var(--primary); }
        
        /* CAMERA PREVIEW */
        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 140px; height: 105px;
            background: #000; border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255,255,255,0.2); opacity: 0; transition: opacity 0.5s;
        }
        #cam-preview video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* TRACKING CURSOR */
        #cursor {
            position: absolute; width: 40px; height: 40px; border: 2px solid var(--primary);
            border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 15px var(--primary);
            transition: opacity 0.2s; opacity: 0; pointer-events: none;
        }
        
        /* FLASH MESSAGE */
        #flash {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: 800; color: #fff; text-shadow: 0 0 20px var(--primary);
            opacity: 0; transition: opacity 0.3s; pointer-events: none; text-transform: uppercase;
        }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <div id="ui-layer">
        <button id="start-btn">Initialize System</button>
        
        <div id="instructions" style="opacity:0">
            <b style="color:var(--primary)">CONTROLS</b><br>
            ðŸ‘† <b>Move Hand:</b> Rotate Particles<br>
            ðŸ‘Œ <b>Pinch (Index+Thumb):</b> Change Shape
        </div>
        
        <div id="status" style="opacity:0">System: STANDBY</div>
        <div id="flash">GALAXY</div>
        <div id="cursor"></div>
        
        <div id="cam-preview">
            <video id="input-video" playsinline muted autoplay></video>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
        const PARTICLE_COUNT = isMobile ? 5000 : 15000; // Increased count for desktop
        const SMOOTHING = 0.12;
        
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(2, devicePixelRatio));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // Glow intensity
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- PARTICLES ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initial random positions
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            positions[i] = (Math.random() - 0.5) * 200;
            colors[i] = 1; // Start white
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: isMobile ? 0.8 : 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE GENERATORS & PALETTES ---
        // Palettes: [Color1, Color2] mixed randomly
        const shapes = [
            { name: "GALAXY", func: galaxy, palette: [new THREE.Color('#00ffff'), new THREE.Color('#ff00ff')] },
            { name: "HEART", func: heart, palette: [new THREE.Color('#ff0055'), new THREE.Color('#ffaa00')] },
            { name: "SPHERE", func: sphere, palette: [new THREE.Color('#00ff88'), new THREE.Color('#0088ff')] },
            { name: "DNA", func: dna, palette: [new THREE.Color('#ffffff'), new THREE.Color('#4444ff')] }
        ];
        let currentShapeIndex = 0;

        function galaxy() {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const r = Math.random() * 50;
                const a = Math.random() * Math.PI * 2 + (r * 0.1); // Spiral
                targets[i*3] = Math.cos(a) * r;
                targets[i*3+1] = (Math.random() - 0.5) * 15;
                targets[i*3+2] = Math.sin(a) * r;
            }
        }
        function heart() {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                const s = 1.5; // Scale
                targets[i*3] = 16 * Math.pow(Math.sin(t), 3) * s;
                targets[i*3+1] = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * s;
                targets[i*3+2] = (Math.random() - 0.5) * 20;
            }
        }
        function sphere() {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 35;
                targets[i*3] = r * Math.sin(phi) * Math.cos(theta);
                targets[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                targets[i*3+2] = r * Math.cos(phi);
            }
        }
        function dna() {
             for(let i=0; i<PARTICLE_COUNT; i++) {
                const t = (i / PARTICLE_COUNT) * 20 * Math.PI;
                const x = Math.cos(t) * 15;
                const y = (i / PARTICLE_COUNT) * 100 - 50;
                const z = Math.sin(t) * 15;
                targets[i*3] = x;
                targets[i*3+1] = y;
                targets[i*3+2] = z;
             }
        }

        // --- TRANSITIONS ---
        function setShape(index) {
            currentShapeIndex = index % shapes.length;
            const shapeData = shapes[currentShapeIndex];
            
            // 1. Calculate new positions
            shapeData.func();
            
            // 2. Update Colors based on palette
            const c1 = shapeData.palette[0];
            const c2 = shapeData.palette[1];
            const colorAttr = geometry.attributes.color;
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const mix = Math.random();
                colorAttr.setXYZ(i, 
                    c1.r * mix + c2.r * (1-mix),
                    c1.g * mix + c2.g * (1-mix),
                    c1.b * mix + c2.b * (1-mix)
                );
            }
            colorAttr.needsUpdate = true;

            // 3. UI Feedback
            const flash = document.getElementById('flash');
            flash.innerText = shapeData.name;
            flash.style.opacity = '1';
            flash.style.transform = 'translate(-50%, -50%) scale(1.2)';
            setTimeout(() => {
                flash.style.opacity = '0';
                flash.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 800);
        }

        // --- HAND TRACKING LOGIC ---
        let handX = 0, handY = 0;
        let targetHandX = 0, targetHandY = 0;
        let isPinched = false;
        let cooldown = false;

        const videoElement = document.getElementById('input-video');
        const cursorElement = document.getElementById('cursor');

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onResults);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];

                // 1. Map Hand Position (Center is 0,0)
                // Inverting X because webcam is mirrored
                targetHandX = (0.5 - indexTip.x) * 150; 
                targetHandY = -(indexTip.y - 0.5) * 100;

                // 2. Update Cursor UI
                const cursorX = (1 - indexTip.x) * 100; // % for CSS
                const cursorY = indexTip.y * 100;
                cursorElement.style.left = `${cursorX}%`;
                cursorElement.style.top = `${cursorY}%`;
                cursorElement.style.opacity = '1';
                document.getElementById('status').innerText = "System: TRACKING";
                document.getElementById('status').style.color = "#00ff88";

                // 3. Detect Pinch
                const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                if (distance < 0.05) {
                    if (!isPinched && !cooldown) {
                        isPinched = true;
                        cooldown = true;
                        setShape(currentShapeIndex + 1);
                        cursorElement.style.borderColor = "#ff0055"; // Red on pinch
                        setTimeout(() => cooldown = false, 1000); // 1s cooldown
                    }
                } else {
                    isPinched = false;
                    cursorElement.style.borderColor = "var(--primary)";
                }
            } else {
                cursorElement.style.opacity = '0';
                document.getElementById('status').innerText = "System: SEARCHING...";
                document.getElementById('status').style.color = "var(--primary)";
            }
        }

        // --- ANIMATION LOOP ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;

            // Smooth hand movement
            handX += (targetHandX - handX) * SMOOTHING;
            handY += (targetHandY - handY) * SMOOTHING;

            // Update Particle Positions
            const posAttr = geometry.attributes.position;
            const pArr = posAttr.array;
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i * 3;
                
                // Move towards target shape + hand offset
                pArr[ix] += (targets[ix] + handX - pArr[ix]) * 0.05;
                pArr[ix+1] += (targets[ix+1] + handY - pArr[ix+1]) * 0.05;
                pArr[ix+2] += (targets[ix+2] - pArr[ix+2]) * 0.05;

                // Add subtle "breathing" noise
                pArr[ix] += Math.sin(time + i) * 0.02;
                pArr[ix+1] += Math.cos(time + i) * 0.02;
            }
            posAttr.needsUpdate = true;

            // Rotate entire cloud slowly
            particles.rotation.y = time * 0.2;
            particles.rotation.z = Math.sin(time * 0.5) * 0.1;

            composer.render();
        }

        // --- INITIALIZATION ---
        const startBtn = document.getElementById('start-btn');
        startBtn.onclick = async () => {
            startBtn.innerText = "Accessing Camera...";
            try {
                const cameraObj = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                await cameraObj.start();
                
                // UI Transitions
                startBtn.style.display = 'none';
                document.getElementById('instructions').style.opacity = '1';
                document.getElementById('status').style.opacity = '1';
                document.getElementById('cam-preview').style.opacity = '1';
                
                setShape(0); // Start
                animate();
            } catch (e) {
                console.error(e);
                alert("Camera access denied or device not supported.");
                startBtn.innerText = "Error";
            }
        };

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            composer.setSize(innerWidth, innerHeight);
        });

    </script>
</body>
</html>
